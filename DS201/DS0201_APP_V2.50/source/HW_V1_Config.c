/******************** (C) COPYRIGHT 2009 e-Design Co.,Ltd. *********************
* File Name: HW_V1_config.c 
     Author: bure   
   Hardware: DS0201V1.1~1.6 
    Version: V1.0
*******************************************************************************/
#include "Function.h"
#include "Interrupt.h"
#include "stm32f10x_systick.h"
#include "HW_V1_Config.h"
unsigned char Key_Status_Last =0;

ErrorStatus HSEStartUpStatus;

/*******************************************************************************
* 函数名    : GPIO_Config   说明   : GPIO端口初始化设置
*******************************************************************************/
void GPIO_Config(void)
{
  GPIOA_CRL = 0x88888080;  /* GPIOA Bit0-7 状态设置
                |||||||+----- Nib0  Ain   模拟输入
                ||||||+------ Nib1  NC    上拉输入
                |||||+------- Nib2  Vbat  模拟输入  
                ||||+-------- Nib3  KB    上拉输入  
                |||+--------- Nib4  KP    上拉输入  
                ||+---------- Nib5  KL    上拉输入  
                |+----------- Nib6  KU    上拉输入  
                +------------ Nib7  KR    上拉输入*/ 
  GPIOA_CRH = 0x8884488B;  /* GPIOA Bit8-15 状态设置
                |||||||+----- Nib8  MCO   复用输出
                ||||||+------ Nib9  NC    上拉输入
                |||||+------- Nib10 NC    上拉输入  
                ||||+-------- Nib11 D-    高阻输入  
                |||+--------- Nib12 D+    高阻输入  
                ||+---------- Nib13 TMS   上拉输入  
                |+----------- Nib14 TCK   上拉输入  
                +------------ Nib15 TDI   上拉输入*/  
  GPIOA_ODR = 0x0FFFF;
  
  GPIOB_CRL = 0x88888411;  /* GPIOB Bit0-7 状态设置
                |||||||+----- Nib0  A     低速输出
                ||||||+------ Nib1  D     低速输出
                |||||+------- Nib2  BT1   高阻输入  
                ||||+-------- Nib3  TDO   上拉输入  
                |||+--------- Nib4  TRST  上拉输入  
                ||+---------- Nib5  NC    上拉输入  
                |+----------- Nib6  NC    上拉输入  
                +------------ Nib7  NC    上拉输入*/  
  GPIOB_CRH = 0xBBB1B488;  /* GPIOB Bit8-15 状态设置
                |||||||+----- Nib8  NC    上拉输入
                ||||||+------ Nib9  NC    上拉输入
                |||||+------- Nib10 Vusb  高阻输入  
                ||||+-------- Nib11 V0    复用输出  
                |||+--------- Nib12 SDCS  低速输出  
                ||+---------- Nib13 SCK   复用输出  
                |+----------- Nib14 MISO  复用输出  
                +------------ Nib15 MOSI  复用输出*/  
  GPIOB_ODR = 0x0FFFF;
  
  GPIOC_CRL = 0x84118881;  /* GPIOB Bit0-7 状态设置
                |||||||+----- Nib0  nCLS  低速输出
                ||||||+------ Nib1  NC    上拉输入
                |||||+------- Nib2  NC    上拉输入  
                ||||+-------- Nib3  NC    上拉输入  
                |||+--------- Nib4  C     低速输出  
                ||+---------- Nib5  B     低速输出  
                |+----------- Nib6  NC    高阻输入  
                +------------ Nib7  NC    上拉输入*/  
  GPIOC_CRH = 0x88888884;  /* GPIOB Bit8-15 状态设置
                |||||||+----- Nib8  NC    高阻输入
                ||||||+------ Nib9  NC    上拉输入
                |||||+------- Nib10 NC    上拉输入  
                ||||+-------- Nib11 NC    上拉输入  
                |||+--------- Nib12 NC    上拉输入  
                ||+---------- Nib13 NC    上拉输入  
                |+----------- Nib14 NC    上拉输入  
                +------------ Nib15 NC    上拉输入*/  
  GPIOC_ODR = 0x0FFFF;
  
  GPIOD_CRL = 0x38338838;  /* GPIOB Bit0-7 状态设置
                |||||||+----- Nib0  NC    上拉输入
                ||||||+------ Nib1  RS    高速输出
                |||||+------- Nib2  NC    上拉输入  
                ||||+-------- Nib3  NC    上拉输入  
                |||+--------- Nib4  nRD   高速输出  
                ||+---------- Nib5  nWR   高速输出  
                |+----------- Nib6  NC    上拉输入  
                +------------ Nib7  nCS   高速输出*/  
  GPIOD_CRH = 0x88838884;  /* GPIOB Bit8-15 状态设置
                |||||||+----- Nib8  NC    上拉输入
                ||||||+------ Nib9  KD    上拉输入
                |||||+------- Nib10 SDDT  上拉输入  
                ||||+-------- Nib11 KM    上拉输入  
                |||+--------- Nib12 Fout  高速输出  复用输出  
                ||+---------- Nib13 NC    上拉输入  
                |+----------- Nib14 NC    上拉输入  
                +------------ Nib15 NC    上拉输入*/  
  GPIOD_ODR = 0x0FF7F;
  
  GPIOE_CRL = 0x33333333;   //Bit0-7  高速输出（LCD_DB0-7 ）
  GPIOE_CRH = 0x33333333;   //Bit8-15 高速输出（LCD_DB8-15）
 
  AFIO_MAPR = 0x00001200;  /* AFIO重映射寄存器 Bit0-31 状态设置
                ||||||++----- 配置为复位值
                |||||+------- Bit9   TIM2_CH3_CH4 重映射至 PB10,PB11
                ||||+-------- Bit12  TIM4_CH1     重映射至 PD12
                ++++--------- 配置为复位值 */ 
}

/*******************************************************************************
* 函数名 : DMA_configuration  说明 : DMA通道1初始化配置,用于ADC结果传输保存
*******************************************************************************/
void DMA_Configuration(void)
{
  DMA_ISR = 0x00000000;/*DMA中断状态寄存器，可通过设置IFCR对应位清除
              |||||||+---GIF1 =0：通道1没产生TE、HT或TC事件全局中断标志
              |||||||+---TCIF1=0：通道1没产生传输完成中断标志
              |||||||+---HTIF1=0：通道1没产生半传输中断标志
              |||||||+---TEIF1=0：通道1没产生传输错误中断标志
              ||||||+----通道2中断标志组
              ||||++-----通道3中断标志组
              ||||++-----通道4中断标志组
              |||+-------通道5中断标志组
              ||+--------通道6中断标志组 
              ||+--------通道7中断标志组 
              +----------保留*/
  DMA_IFCR= 0x00000000;/*DMA中断标志清除寄存器，可由软件设置或清除
              |||||||+---CGIF1 =1：清除通道1的TE、HT或TC事件全局中断标志
              |||||||+---CTCIF1=1：清除通道1的传输完成中断标志
              |||||||+---CHTIF1=1：清除通道1的半传输中断标志
              |||||||+---CTEIF1=1：清除通道1的传输错误中断标志
              ||||||+----清除通道2中断标志组
              ||||++-----清除通道3中断标志组
              ||||++-----清除通道4中断标志组
              |||+-------清除通道5中断标志组
              ||+--------清除通道6中断标志组 
              ||+--------清除通道7中断标志组 
              +----------保留*/
  DMA_CCR1=  0x00003580;/*0011 0101 1000 0000  
               ||||       |||| |||| |||| |||+--EN = 0：通道关闭，1：通道开启
               ||||       |||| |||| |||| ||+---TCIE=0：不允许传输完成中断
               ||||       |||| |||| |||| |+----HTIE=0：禁止半传输中断
               ||||       |||| |||| |||| +-----TEIE=0：禁止传输错误中断
               ||||       |||| |||| |||+-------DIR =0：数据传输方向（从外设读）
               ||||       |||| |||| ||+--------CIRC=0：不执行循环操作
               ||||       |||| |||| |+---------PINC=0：不执行外设地址增量模式 
               ||||       |||| |||| +----------MINC=1：执行存储器地址增量模式
               ||||       |||| ||++------------PSIZE=01：16位外设数据宽度
               ||||       |||| ++--------------MSIZE=01：16位存储器数据宽度
               ||||       ||++-----------------PL=11：最高通道优先级
               ||||       |+-------------------MEM2MEM=0：非存储器到存储器模式
               ++++-------+--------------------保留*/

  DMA_CNDTR1=0x00001000;          //DMA通道1传输数量寄存器(1024*2 Bytes)  
  DMA_CPAR1 = ADC1_DR_ADDR;       //DMA通道1的外设数据寄存器基地址 
  DMA_CMAR1 =(u32)&Scan_Buffer[0];//DMA通道1的源或目标的存储器地址
  DMA_CCR1 |= 0x00000001;         // EN = 1：DMA通道1开启 
}
/*******************************************************************************
* 函数名    : ADC_configuration  说明  : ADC初始化，采样完成后自动DMA到缓冲区
*******************************************************************************/
void ADC_Configuration(void)
{
  ADC2_CR1 =0x00000000;
  ADC1_CR1 =0x00000000;/*
              ||||||++---AWDCH[4:0]：模拟看门狗通道选择位 
              ||||||+----=000：不允许EOC、AWD、JEOC中断
              |||||+-----Nib8_SCAN=0：不使用扫描模式
              ||||++-----保持复位值
              |||+-------DUALMOD=0：独立模式
              ||+--------规则通道和注入通道禁用模拟看门狗 
              ++---------保留*/
  ADC2_CR2 =0x00100000;
  ADC1_CR2 =0x00100100;/*
              |||||||+---ADON=0：关闭ADC转换/校准，=1：开启ADC并启动转换
              |||||||+---CONT=0：1：连续转换模式
              |||||||+---CAL=0，=1：A/D校开始准，校准后该位将被硬件清除
              |||||||+---RSTCAL=0，=1：初始化校准寄存器，校准后该位将被硬件清除
              ||||||+----保留
              |||||+-----ALIGN=0 & DMA=1：数据右对齐和使用DMA模式
              ||||+------
              |||+-------=0000：规则通道使用定时器1的CC1事件启动转换，=1110：SWSTART
              ||+--------=1：使用外部触发信号启动转换 
              ++---------保留*/
  ADC2_SQR1=0x00000000;
  ADC1_SQR1=0x00000000;/*ADC规则序列寄存器 1
              ||++++++---SQ13-16=00000：转换序列中第13-16个转换通道编号(5Bits*4)
              ++---------保留*/
  ADC2_SQR3 =0x00000002;
  ADC1_SQR3 =0x00000000;/*ADC规则序列寄存器 3
               ||||||++---SQ1=00000：转换序列中的第1个转换通道的编号(0)
               +++++++----SQ2-6=00000：转换序列中第2-6个转换通道编号(5Bits*5)
               +----------保留*/
  ADC2_SMPR2=0x00000000;
  ADC1_SMPR2=0x00000000;/*ADC采样时间寄存器 1   
               |||||||+---SMP01=001(3Bits)：使通道00的采样时间 1.5T   
               ||||+------SMP04=001(3Bits)：使通道04的采样时间 7.5T
               |+++++++---SMP11-17=000(3Bits*7)：通道11-17的采样时间 1.5T
               ++---------保留*/
  ADC1_CR2 |=0x00000001; 
  ADC2_CR2 |=0x00000001;       //ADON=1：开启ADC1、ADC2
  ADC1_CR2 |=0x00000008; 
  while(ADC1_CR2 & 0x00000008);//初始化ADC1校准寄存器
  ADC2_CR2 |=0x00000008; 
  while(ADC2_CR2 & 0x00000008);//初始化ADC2校准寄存器
  ADC1_CR2 |=0x00000004; 
  while(ADC1_CR2 & 0x00000004);//ADC1校准
  ADC2_CR2 |=0x00000004; 
  while(ADC2_CR2 & 0x00000004);//ADC2校准
}
/*******************************************************************************
* 函数名 : Timer_configuration    说明 : 系统定时器初始化配置
*******************************************************************************/
void Timer_Configuration(void)
{
//---------------TIM1用于定时触发ADC采样-------------------
  Set_Base(Item_Index[2]);  
  TIM1_CR1 = 0x0094;/*0000 0000 1001 0100  
                      |||| |||| |||| |||+---CEN=0，禁止计数器
                      |||| |||| |||| ||+----UDIS=0，允许UEV更新
                      |||| |||| |||| |+-----URS=1：只有计数器溢出产生中断或DMA请求 
                      |||| |||| |||| +------OPM=0：在发生更新事件时，计数器不停止 
                      |||| |||| |||+--------DIR=1，计数器向下计数
                      |||| |||| |++---------CMS=00，选择边沿对齐模式
                      |||| |||| +-----------ARPE=1，TIM1_ARR寄存器被装入缓冲器
                      |||| ||++-------------CKD=00,CK_INT分频比为1
                      ++++-++---------------保留*/
  TIM1_RCR = 0x0000;/*0000 0000 0000 0001  
                      |||| |||| ++++ ++++---在边沿对齐模式下，PWM周期的数目+1
                      ++++-++++-------------保留*/
  TIM1_CCER =0x0001;/*0000 0000 0000 0001  
                      |||| |||| |||| |||+---CC1E=1，OC1信号输出到对应的输出引脚
                      |||| |||| |||| ||+----CC1P=0，OC1高电平有效
                      |||| |||| |||| |+-----CC1NE=0，OC1N禁止输出
                      |||| |||| |||| +------CC1NP=0，OC1N高电平有效
                      ++++-++++-++++--------CC2、CC3、CC4配置为复位值*/
  TIM1_CCMR1=0x0078;/*0000 0000 0111 1100  
                      |||| |||| |||| ||++---CC1S=00，CC1通道被配置为输出
                      |||| |||| |||| |+-----OC1FE=1，允输出比较1 快速使能？
                      |||| |||| |||| +------OC1PE=1，输出比较1预装载使能 
                      |||| |||| |+++--------0C1M=111，PWM模式2
                      |||| |||| +-----------OC1CE=0，OC1REF 不受ETRF输入的影响
                      ++++-++++-------------CC2通道配置为复位值*/
  TIM1_BDTR =0x8000;/*1000 0000 0000 0000  
                      |+++-++++-++++-++++---其它位保持不变 
                      +---------------------MOE=0，主输出使能*/
  TIM1_DIER =0x4200;/*0100 0011 0000 0000  DMA和中断使能寄存器
                       |     ||        +----CC1IE=0：不允许捕获/比较1中断
                       |     |+-------------UDE=1：允许更新的DMA请求
                       |     +--------------CC1DE=1：允许捕获/比较1的DMA请求
                       +--------------------TDE=1：允许触发DMA请求*/
  TIM1_CR1 |=0x0001;//CEN=1，使能TIMER1计数器 

//-----------------TIM2_CH4用于PWM输出Y通道偏移电压值-------------------  
  TIM2_PSC =0;  
  TIM2_ARR =3839;              //72MHz/3840=18.75KHz 
  Set_Y_Pos(Item_Index[Y_SENSITIVITY], Item_Index[V0]);  
  TIM2_CR1 = 0x0084;/*0000 0000 1000 0100  
                      |||| |||| |||| |||+---CEN=0，禁止计数器
                      |||| |||| |||| ||+----UDIS=0，允许UEV更新
                      |||| |||| |||| |+-----URS=1：只有计数器溢出产生中断或DMA请求 
                      |||| |||| |||| +------OPM=0：在发生更新事件时，计数器不停止 
                      |||| |||| |||+--------DIR=0，计数器向上计数
                      |||| |||| |++---------CMS=00，选择边沿对齐模式
                      |||| |||| +-----------ARPE=1，TIM2_ARR寄存器被装入缓冲器
                      |||| ||++-------------CKD=00,CK_INT分频比为1
                      ++++-++---------------保留*/
  TIM2_CCER =0x3000;/*0011 0000 0000 0000  
                      |||| ++++-++++-++++---CC1、CC2、CC3配置为复位值
                      |||+------------------CC4E=1，OC4信号输出到对应的输出引脚
                      ||+-------------------CC4P=1，OC4低电平有效
                      |+--------------------CC4NE=0，OC4N禁止输出
                      +---------------------CC4NP=0，OC4N高电平有效*/
  TIM2_CCMR2=0x7C00;/*0111 1100 0000 0000  
                      |||| |||| ++++-++++---CC3通道配置为复位值
                      |||| ||++-------------CC4S=00，CC4通道被配置为输出
                      |||| |+---------------OC4FE=1，允输出比较4 快速使能？
                      |||| +----------------OC4PE=1，输出比较4预装载使能 
                      |+++------------------0C4M=111，PWM模式2
                      +---------------------OC4CE=0，OC4REF 不受ETRF输入的影响*/
  TIM2_CR1 |=0x0001;//CEN=1，使能TIMER2计数器 

//-----------------TIM3用于系统定时-------------------  
  TIM3_PSC  =9; 
  TIM3_ARR  =7199;  //1mS 脉冲周期=（PSC+1）×（ARR+1）/（72MHz/2）（uS）
  TIM3_CCR1 =3600; //脉冲宽度（占空比）50%
  TIM3_CR1 = 0x0084;/*0000 0000 1000 0100  
                      |||| |||| |||| |||+---CEN=0，禁止计数器
                      |||| |||| |||| ||+----UDIS=0，允许UEV更新
                      |||| |||| |||| |+-----URS=1：只有计数器溢出产生中断或DMA请求 
                      |||| |||| |||| +------OPM=0：在发生更新事件时，计数器不停止 
                      |||| |||| |||+--------DIR=0，计数器向上计数
                      |||| |||| |++---------CMS=00，选择边沿对齐模式
                      |||| |||| +-----------ARPE=1，TIM3_ARR寄存器被装入缓冲器
                      |||| ||++-------------CKD=00,CK_INT分频比为1
                      ++++-++---------------保留*/
  TIM3_DIER =0x0002;/*0000 0000 0000 0010  DMA和中断使能寄存器
                             |         +----CC1IE=1：允许捕获/比较1中断
                             +--------------CC1DE=1：允许捕获/比较1的DMA请求*/
  TIM3_CR1 |=0x0001;//CEN=1，使能TIMER3计数器 

//------------------TIM4_CH1用于输出选定频率的标准方波----------------------
  TIM4_PSC = 7;
  TIM4_ARR = Fout_ARR[Item_Index[11]];        //脉冲周期
  TIM4_CCR1 = (Fout_ARR[Item_Index[11]]+1)/2; //脉冲宽度0.5mS（占空比约：50%）
  TIM4_CR1 = 0x0084;/*0000 0000 1000 0100  
                      |||| |||| |||| |||+---CEN=0，禁止计数器
                      |||| |||| |||| ||+----UDIS=0，允许UEV更新
                      |||| |||| |||| |+-----URS=1：只有计数器溢出产生中断或DMA请求 
                      |||| |||| |||| +------OPM=0：在发生更新事件时，计数器不停止 
                      |||| |||| |||+--------DIR=0，计数器向上计数
                      |||| |||| |++---------CMS=00，选择边沿对齐模式
                      |||| |||| +-----------ARPE=1，TIM3_ARR寄存器被装入缓冲器
                      |||| ||++-------------CKD=00,CK_INT分频比为1
                      ++++-++---------------保留*/
  TIM4_CCER =0x0001;/*0000 0000 0000 0001  
                      |||| |||| |||| |||+---CC1E=1，OC1信号输出到对应的输出引脚
                      |||| |||| |||| ||+----CC1P=0，OC1高电平有效
                      |||| |||| |||| |+-----CC1NE=0，OC1N禁止输出
                      |||| |||| |||| +------CC1NP=0，OC1N高电平有效
                      ++++-++++-++++--------CC2、CC3、CC4配置为复位值*/
  TIM4_CCMR1=0x0078;/*0000 0000 0111 1100  
                      |||| |||| |||| ||++---CC1S=00，CC1通道被配置为输出
                      |||| |||| |||| |+-----OC1FE=1，允输出比较1 快速使能？
                      |||| |||| |||| +------OC1PE=1，输出比较1预装载使能 
                      |||| |||| |+++--------0C1M=111，PWM模式2
                      |||| |||| +-----------OC1CE=0，OC1REF 不受ETRF输入的影响
                      ++++-++++-------------CC2通道配置为复位值*/
  TIM4_CR1 |=0x0001;//CEN=1，使能TIMER4计数器 
}
/*******************************************************************************
* 函数名：KeyScan    说明：读取按键  返回：按键扫描码，KeyBuff=按键码
*******************************************************************************/
char KeyScan(void)
{
  char Key_Status_Now=0, KeyCode=0;
  
  if((~GPIOA_IDR) & 0x0010) Key_Status_Now |= 0x01; //KEY_PLAY_ON (KEY_A)
  if((~GPIOD_IDR) & 0x0800) Key_Status_Now |= 0x02; //KEY_MENU_ON (KEY_OK)
  if((~GPIOA_IDR) & 0x0040) Key_Status_Now |= 0x04; //KEY_UP_ON
  if((~GPIOD_IDR) & 0x0200) Key_Status_Now |= 0x08; //KEY_DOWN_ON
  if((~GPIOA_IDR) & 0x0020) Key_Status_Now |= 0x10; //KEY_LEFT_ON
  if((~GPIOA_IDR) & 0x0080) Key_Status_Now |= 0x20; //KEY_RIGHT_ON
  if((~GPIOA_IDR) & 0x0008) Key_Status_Now |= 0x40; //KEY_B_ON
  
  if(Key_Status_Now &(~Key_Status_Last)){
    
    Key_Wait_Counter=25;        //持续按键500mS内，不启动自动重复功能
    
    if(Key_Status_Now & 0x01)  KeyCode=KEYCODE_PLAY; // KeyCode(Play/A) 
    if(Key_Status_Now & 0x02)  KeyCode=KEYCODE_MANU; // KeyCode(Manu/OK) 
    if(Key_Status_Now & 0x04)  KeyCode=KEYCODE_UP;   // KeyCode(Up) 
    if(Key_Status_Now & 0x08)  KeyCode=KEYCODE_DOWN; // KeyCode(Down) 
    if(Key_Status_Now & 0x10)  KeyCode=KEYCODE_LEFT; // KeyCode(Left) 
    if(Key_Status_Now & 0x20)  KeyCode=KEYCODE_RIGHT;// KeyCode(Right) 
    
  } else {
      
    if(Key_Status_Now & Key_Status_Last){
      if((Key_Wait_Counter | Key_Repeat_Counter)==0){
        if(Key_Status_Now & 0x04)  KeyCode=KEYCODE_UP;   // KeyCode(Up) 
        if(Key_Status_Now & 0x08)  KeyCode=KEYCODE_DOWN; // KeyCode(Down) 
        if(Key_Status_Now & 0x10)  KeyCode=KEYCODE_LEFT; // KeyCode(Left) 
        if(Key_Status_Now & 0x20)  KeyCode=KEYCODE_RIGHT;// KeyCode(Right)
        
        Key_Repeat_Counter = 3; //每60mS自动重复一次
      }
    }else Key_Wait_Counter=25;      //持续按键500mS内，不启动自动重复功能
  }
  Key_Status_Last = Key_Status_Now;
  return KeyCode;
}    
/*******************************************************************************
 Battery_Detect: 检测电池电压及充放电状态 
*******************************************************************************/
void Battery_Detect(void)
{   
  unsigned int vb;
//  vb =(123*(*((vu16 *)(ADC1_DR_ADDR+2))))>>10;
  vb =(133*(*((vu16 *)(ADC1_DR_ADDR+2))))>>10;
  Battery=vb_Sum/32; 
//  Battery=vb; 
  vb_Sum=vb_Sum+vb-Battery; 
  Update[5]=1;
//  if(Battery>380)    //Ver2.01
  if(Battery>390)      //Ver2.02
    Item_Index[5]=3;
  else  
    if(Battery>350)  
      Item_Index[5]=2;
    else  
      if(Battery>320)  
        Item_Index[5]=1;
      else  
        Item_Index[5]=0;
}
/*******************************************************************************
 Set_Range: 电压量程转换模拟开关状态设置 
*******************************************************************************/
void Set_Range(char Range)
{   

  switch (Range) {
    case 0://10mV ×1/Div   
    case 1://20mV ×1/Div   
    case 2://50mV ×1/Div   
    case 3://0.1V ×1/Div   
      RANGE_A_HIGH(); 
      RANGE_B_HIGH(); 
      RANGE_C_HIGH(); 
      RANGE_D_HIGH(); 
    break;
    case 4://0.2V ×1/Div实    
    case 5://0.5V ×1/Div   
    case 6://1V ×1/Div   
      RANGE_A_HIGH(); 
      RANGE_B_HIGH(); 
      RANGE_C_HIGH(); 
      RANGE_D_LOW(); 
    break;
    case 7://2V ×1/Div    
    case 8://5V ×1/Div
    case 9://10V ×1/Div
      RANGE_A_LOW(); 
      RANGE_B_HIGH(); 
      RANGE_C_HIGH(); 
      RANGE_D_LOW(); 
    break;
    case 10://0.2V/Div （20mV ×10/Div） 
    case 11://0.5V/Div （50mV ×10/Div）
    case 12://  1V/Div （0.1V ×10/Div）
      RANGE_A_HIGH(); 
      RANGE_B_LOW(); 
      RANGE_C_HIGH(); 
      RANGE_D_LOW(); 
    break;
    case 13:// 2V/Div （0.2V ×10/Div）
    case 14:// 5V/Div （0.5V ×10/Div）
    case 15://10V/Div （  1V ×10/Div）
      RANGE_A_LOW(); 
      RANGE_B_LOW(); 
      RANGE_C_HIGH(); 
      RANGE_D_LOW(); 
    break;
    case 16:// 20V/Div （ 2V ×10/Div）
    case 17:// 50V/Div （ 5V ×10/Div）
    case 18://100V/Div （10V ×10/Div）
      RANGE_A_HIGH(); 
      RANGE_B_HIGH(); 
      RANGE_C_LOW(); 
      RANGE_D_LOW(); 
    break;
    default : //Connecte To GND
      RANGE_A_LOW(); 
      RANGE_B_LOW(); 
      RANGE_C_LOW(); 
      RANGE_D_LOW(); 
    break;
  }
}

/*******************************************************************************
 Set_Base: 水平扫描时基转换设置 
*******************************************************************************/
void Set_Base(char Base)
{   
  TIM1_PSC = Scan_PSC[Base];
  TIM1_ARR = Scan_ARR[Base];
  TIM1_CCR1=(Scan_ARR[Base]+1)/2;
}
/*******************************************************************************
 ADC_Start: 重新开始ADC扫描采样
*******************************************************************************/
void ADC_Start(void) 
{  
  DMA_CCR1 = 0x00000000;           
  DMA_CMAR1 =(u32)&Scan_Buffer[0];        //重新设定DMA通道1
  DMA_CNDTR1 = 0x00001000;         
  DMA_CCR1 |= 0x00000001;                 //重新开始扫描采样
}
/*******************************************************************************
 Set_Y_Pos: 零电压基线调整设置
*******************************************************************************/
void Set_Y_Pos(unsigned short i, unsigned short Y0) 
{  
  TIM2_CCR4 =((240-Y0)*Y_POSm[i])/32+Y_POSn[i];

}
/*******************************************************************************
 Test_USB_ON: 检测外接USB状态
*******************************************************************************/
char Test_USB_ON(void) 
{ 
  if(GPIOB_IDR & 0x0400) return 1;
  else  return 0;
}

/*******************************************************************************
 SD_Card_ON: 检测SD_Card状态
*******************************************************************************/
char SD_Card_ON(void) 
{ 
  if(GPIOD_IDR & 0x0400 ) return 0;
  else                    return 1; //SD_Card_ON
}

/******************************** END OF FILE *********************************/
